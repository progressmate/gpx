// Code generated by xsdgen. DO NOT EDIT.

package gpx

import (
	"bytes"
	"encoding/xml"
	"time"
)

// Two lat/lon pairs defining the extent of an element.
type Bounds struct {
	Minlat float64 `xml:"minlat,attr"`
	Minlon float64 `xml:"minlon,attr"`
	Maxlat float64 `xml:"maxlat,attr"`
	Maxlon float64 `xml:"maxlon,attr"`
}

// Information about the copyright holder and any license governing use of this file. By
// linking to an appropriate license, you may place your data into the public domain or grant additional
// usage rights.
type Copyright struct {
	Year    time.Time `xml:"http://www.topografix.com/GPX/1/1 year,omitempty"`
	License string    `xml:"http://www.topografix.com/GPX/1/1 license,omitempty"`
	Author  string    `xml:"author,attr"`
}

func (t *Copyright) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T Copyright
	var layout struct {
		*T
		Year *xsdGYear `xml:"http://www.topografix.com/GPX/1/1 year,omitempty"`
	}
	layout.T = (*T)(t)
	layout.Year = (*xsdGYear)(&layout.T.Year)
	return e.EncodeElement(layout, start)
}
func (t *Copyright) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Copyright
	var overlay struct {
		*T
		Year *xsdGYear `xml:"http://www.topografix.com/GPX/1/1 year,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.Year = (*xsdGYear)(&overlay.T.Year)
	return d.DecodeElement(&overlay, &start)
}

// An email address. Broken into two parts (id and domain) to help prevent email
// harvesting.
type Email struct {
	Domain string `xml:"domain,attr"`
}

// You can add extend GPX by adding your own elements from another schema here.
type Extensions []string

func (a Extensions) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	var output struct {
		ArrayType string   `xml:"http://schemas.xmlsoap.org/wsdl/ arrayType,attr"`
		Items     []string `xml:" item"`
	}
	output.Items = []string(a)
	start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{"", "xmlns:ns1"}, Value: "http://www.w3.org/2001/XMLSchema"})
	output.ArrayType = "ns1:anyType[]"
	return e.EncodeElement(&output, start)
}
func (a *Extensions) UnmarshalXML(d *xml.Decoder, start xml.StartElement) (err error) {
	var tok xml.Token
	for tok, err = d.Token(); err == nil; tok, err = d.Token() {
		if tok, ok := tok.(xml.StartElement); ok {
			var item string
			if err = d.DecodeElement(&item, &tok); err == nil {
				*a = append(*a, item)
			}
		}
		if _, ok := tok.(xml.EndElement); ok {
			break
		}
	}
	return err
}

// May be one of none, 2d, 3d, dgps, pps
type Fix string

// GPX documents contain a metadata header, followed by waypoints, routes, and tracks. You
// can add your own elements to the extensions section of the GPX document.
type GPX struct {
	Metadata   Metadata   `xml:"http://www.topografix.com/GPX/1/1 metadata,omitempty"`
	Wpt        []Wpt      `xml:"http://www.topografix.com/GPX/1/1 wpt,omitempty"`
	Rte        []Rte      `xml:"http://www.topografix.com/GPX/1/1 rte,omitempty"`
	Trk        []Trk      `xml:"http://www.topografix.com/GPX/1/1 trk,omitempty"`
	Extensions Extensions `xml:"http://www.topografix.com/GPX/1/1 extensions,omitempty"`
	Version    string     `xml:"version,attr"`
	Creator    string     `xml:"creator,attr"`
}

// A link to an external resource (Web page, digital photo, video clip, etc) with additional
// information.
type Link struct {
	Text string `xml:"http://www.topografix.com/GPX/1/1 text,omitempty"`
	Type string `xml:"http://www.topografix.com/GPX/1/1 type,omitempty"`
}

// Information about the GPX file, author, and copyright restrictions goes in the metadata
// section. Providing rich, meaningful information about your GPX files allows others to search for and use
// your GPS data.
type Metadata struct {
	Name       string     `xml:"http://www.topografix.com/GPX/1/1 name,omitempty"`
	Desc       string     `xml:"http://www.topografix.com/GPX/1/1 desc,omitempty"`
	Author     Person     `xml:"http://www.topografix.com/GPX/1/1 author,omitempty"`
	Copyright  Copyright  `xml:"http://www.topografix.com/GPX/1/1 copyright,omitempty"`
	Link       []Link     `xml:"http://www.topografix.com/GPX/1/1 link,omitempty"`
	Time       time.Time  `xml:"http://www.topografix.com/GPX/1/1 time,omitempty"`
	Keywords   string     `xml:"http://www.topografix.com/GPX/1/1 keywords,omitempty"`
	Bounds     Bounds     `xml:"http://www.topografix.com/GPX/1/1 bounds,omitempty"`
	Extensions Extensions `xml:"http://www.topografix.com/GPX/1/1 extensions,omitempty"`
}

func (t *Metadata) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T Metadata
	var layout struct {
		*T
		Time *xsdDateTime `xml:"http://www.topografix.com/GPX/1/1 time,omitempty"`
	}
	layout.T = (*T)(t)
	layout.Time = (*xsdDateTime)(&layout.T.Time)
	return e.EncodeElement(layout, start)
}
func (t *Metadata) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Metadata
	var overlay struct {
		*T
		Time *xsdDateTime `xml:"http://www.topografix.com/GPX/1/1 time,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.Time = (*xsdDateTime)(&overlay.T.Time)
	return d.DecodeElement(&overlay, &start)
}

// A person or organization.
type Person struct {
	Name  string `xml:"http://www.topografix.com/GPX/1/1 name,omitempty"`
	Email Email  `xml:"http://www.topografix.com/GPX/1/1 email,omitempty"`
	Link  Link   `xml:"http://www.topografix.com/GPX/1/1 link,omitempty"`
}

// A geographic point with optional elevation and time. Available for use by other
// schemas.
type Pt struct {
	Ele  float64   `xml:"http://www.topografix.com/GPX/1/1 ele,omitempty"`
	Time time.Time `xml:"http://www.topografix.com/GPX/1/1 time,omitempty"`
	Lat  float64   `xml:"lat,attr"`
	Lon  float64   `xml:"lon,attr"`
}

func (t *Pt) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T Pt
	var layout struct {
		*T
		Time *xsdDateTime `xml:"http://www.topografix.com/GPX/1/1 time,omitempty"`
	}
	layout.T = (*T)(t)
	layout.Time = (*xsdDateTime)(&layout.T.Time)
	return e.EncodeElement(layout, start)
}
func (t *Pt) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Pt
	var overlay struct {
		*T
		Time *xsdDateTime `xml:"http://www.topografix.com/GPX/1/1 time,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.Time = (*xsdDateTime)(&overlay.T.Time)
	return d.DecodeElement(&overlay, &start)
}

// An ordered sequence of points. (for polygons or polylines, e.g.)
type Ptseg struct {
	Pt []Pt `xml:"http://www.topografix.com/GPX/1/1 pt,omitempty"`
}

// rte represents route - an ordered list of waypoints representing a series of turn points
// leading to a destination.
type Rte struct {
	Name       string     `xml:"http://www.topografix.com/GPX/1/1 name,omitempty"`
	Cmt        string     `xml:"http://www.topografix.com/GPX/1/1 cmt,omitempty"`
	Desc       string     `xml:"http://www.topografix.com/GPX/1/1 desc,omitempty"`
	Src        string     `xml:"http://www.topografix.com/GPX/1/1 src,omitempty"`
	Link       []Link     `xml:"http://www.topografix.com/GPX/1/1 link,omitempty"`
	Number     int        `xml:"http://www.topografix.com/GPX/1/1 number,omitempty"`
	Type       string     `xml:"http://www.topografix.com/GPX/1/1 type,omitempty"`
	Extensions Extensions `xml:"http://www.topografix.com/GPX/1/1 extensions,omitempty"`
	Rtept      []Wpt      `xml:"http://www.topografix.com/GPX/1/1 rtept,omitempty"`
}

// trk represents a track - an ordered list of points describing a path.
type Trk struct {
	Name       string     `xml:"http://www.topografix.com/GPX/1/1 name,omitempty"`
	Cmt        string     `xml:"http://www.topografix.com/GPX/1/1 cmt,omitempty"`
	Desc       string     `xml:"http://www.topografix.com/GPX/1/1 desc,omitempty"`
	Src        string     `xml:"http://www.topografix.com/GPX/1/1 src,omitempty"`
	Link       []Link     `xml:"http://www.topografix.com/GPX/1/1 link,omitempty"`
	Number     int        `xml:"http://www.topografix.com/GPX/1/1 number,omitempty"`
	Type       string     `xml:"http://www.topografix.com/GPX/1/1 type,omitempty"`
	Extensions Extensions `xml:"http://www.topografix.com/GPX/1/1 extensions,omitempty"`
	Trkseg     []Trkseg   `xml:"http://www.topografix.com/GPX/1/1 trkseg,omitempty"`
}

// A Track Segment holds a list of Track Points which are logically connected in order. To
// represent a single GPS track where GPS reception was lost, or the GPS receiver was turned off, start a
// new Track Segment for each continuous span of track data.
type Trkseg struct {
	Trkpt      []Wpt      `xml:"http://www.topografix.com/GPX/1/1 trkpt,omitempty"`
	Extensions Extensions `xml:"http://www.topografix.com/GPX/1/1 extensions,omitempty"`
}

// wpt represents a waypoint, point of interest, or named feature on a map.
type Wpt struct {
	Ele           float64    `xml:"http://www.topografix.com/GPX/1/1 ele,omitempty"`
	Time          time.Time  `xml:"http://www.topografix.com/GPX/1/1 time,omitempty"`
	Magvar        float64    `xml:"http://www.topografix.com/GPX/1/1 magvar,omitempty"`
	Geoidheight   float64    `xml:"http://www.topografix.com/GPX/1/1 geoidheight,omitempty"`
	Name          string     `xml:"http://www.topografix.com/GPX/1/1 name,omitempty"`
	Cmt           string     `xml:"http://www.topografix.com/GPX/1/1 cmt,omitempty"`
	Desc          string     `xml:"http://www.topografix.com/GPX/1/1 desc,omitempty"`
	Src           string     `xml:"http://www.topografix.com/GPX/1/1 src,omitempty"`
	Link          []Link     `xml:"http://www.topografix.com/GPX/1/1 link,omitempty"`
	Sym           string     `xml:"http://www.topografix.com/GPX/1/1 sym,omitempty"`
	Type          string     `xml:"http://www.topografix.com/GPX/1/1 type,omitempty"`
	Fix           Fix        `xml:"http://www.topografix.com/GPX/1/1 fix,omitempty"`
	Sat           int        `xml:"http://www.topografix.com/GPX/1/1 sat,omitempty"`
	Hdop          float64    `xml:"http://www.topografix.com/GPX/1/1 hdop,omitempty"`
	Vdop          float64    `xml:"http://www.topografix.com/GPX/1/1 vdop,omitempty"`
	Pdop          float64    `xml:"http://www.topografix.com/GPX/1/1 pdop,omitempty"`
	Ageofdgpsdata float64    `xml:"http://www.topografix.com/GPX/1/1 ageofdgpsdata,omitempty"`
	Dgpsid        int        `xml:"http://www.topografix.com/GPX/1/1 dgpsid,omitempty"`
	Extensions    Extensions `xml:"http://www.topografix.com/GPX/1/1 extensions,omitempty"`
	Lat           float64    `xml:"lat,attr"`
	Lon           float64    `xml:"lon,attr"`
}

func (t *Wpt) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T Wpt
	var layout struct {
		*T
		Time *xsdDateTime `xml:"http://www.topografix.com/GPX/1/1 time,omitempty"`
	}
	layout.T = (*T)(t)
	layout.Time = (*xsdDateTime)(&layout.T.Time)
	return e.EncodeElement(layout, start)
}
func (t *Wpt) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Wpt
	var overlay struct {
		*T
		Time *xsdDateTime `xml:"http://www.topografix.com/GPX/1/1 time,omitempty"`
	}
	overlay.T = (*T)(t)
	overlay.Time = (*xsdDateTime)(&overlay.T.Time)
	return d.DecodeElement(&overlay, &start)
}

type xsdDateTime time.Time

func (t *xsdDateTime) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDateTime) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
func _unmarshalTime(text []byte, t *time.Time, format string) (err error) {
	s := string(bytes.TrimSpace(text))
	*t, err = time.Parse(format, s)
	if _, ok := err.(*time.ParseError); ok {
		*t, err = time.Parse(format+"Z07:00", s)
	}
	return err
}
func _marshalTime(t time.Time, format string) ([]byte, error) {
	return []byte(t.Format(format + "Z07:00")), nil
}

type xsdGYear time.Time

func (t *xsdGYear) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006")
}
func (t xsdGYear) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006")
}
func (t xsdGYear) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdGYear) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
